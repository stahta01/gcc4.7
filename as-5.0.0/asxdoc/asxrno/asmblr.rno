.comment;asmblr.rno

.chapter;The Assembler
.header level 1;The ASxxxx Assemblers

The ASxxxx assemblers are a series of microprocessor assemblers
written in the C programming language. Each
assembler has a device specific section which includes:

.list 1
.list element
device description, byte order, and file extension information
.list element
a table of the assembler general directives, special device directives,
assembler mnemonics and associated operation codes
.list element
machine specific code for processing the device mnemonics,
addressing modes, and special directives
.end list

.break
The device specific information is detailed in the appendices.

The assemblers have a common device independent section which
handles the details of file input_/output, symbol table generation,
program_/data areas, expression analysis, and assembler directive
processing.
.skip
The assemblers provide the following features:

.list 1
.list element;Command string control of assembly functions
.list element;Alphabetized, formatted symbol table listing
.list element;Relocatable object modules
.list element;Global symbols for linking object modules
.list element;Conditional assembly directives
.list element;Program sectioning directives
.end list

ASxxxx assembles one or more source files
into a single relocatable ascii object file. The output
of the ASxxxx assemblers consists of an ascii relocatable object
file(*.rel), an assembly listing file(*.lst), and a symbol file(*.sym).


.header level 2;Assembly Pass 1

During pass 1, ASxxxx opens all source files and performs a rudimenatry
assembly of each source statement. During this process all symbol tables
are built, program sections defined, and number of bytes for each
assembled source line is estimated.

At the end of pass 1 all undefined symbols may be made global (external)
using the ASxxxx switch -g, otherwise undefined symbols will be flagged
as errors during succeeding passes.


.header level 2;Assembly Pass 2

During pass 2 the ASxxxx assembler resolves forward references and determines
the number of bytes for each assembled line. The number of bytes used
by a particular assembler instruction may depend upon the addressing mode,
whether the instruction allows multiple forms based upon the relative
distance to the addressed location, or other factors. Pass 2 resolves these
cases and determines the address of all symbols.


.header level 2;Assembly Pass 3

Pass 3 by the assembler generates the listing file, the relocatable
output file, and the symbol tables. Also during pass 3 the errors will
be reported.

The relocatable object file is an ascii file containing symbol references
and definitions, program area definitions, and the relocatable assembled
code, the linker ASLINK will use this information to generate an absolute
load file (Intel, Motorola or Tandy CoCo Disk Basic formats).


.header level 1;SOURCE PROGRAM FORMAT


.header level 2;Statement Format

A source program is composed of assembly-language statements. Each statement
must be completed on one line. A line may contain a maximum of 128 characters,
longer lines are truncated and lost.

An ASxxxx assembler statement may have as many as four fields. These
fields are identified by their order within the statement and/or by
separating characters between fields. The general format of the
ASxxxx statement is:

.skip;.break;.indent 6
[label:]	Operator	Operand		[;Comment(s)]

The label and comment fields are optional. The operator and operand
fields are interdependent. The operator field may be an assembler
directive or an assembly mnemonic. The operand field may be optional
or required as defined in the context of the operator.

ASxxxx interprets and processes source statements one at a time.
Each statement causes a particular operation to be performed.


.header level 3;Label Field

A label is a user-defined symbol which is assigned the value of the
current location counter and entered into the user defined symbol
table.  The current location counter is used by ASxxxx to assign memory
addresses to the source program statements as they are encountered during the
assembly process.  Thus a label is a means of symbolically referring
to a specific statement.

When a program section is absolute, the value of the current location
counter is absolute; its value references an absolute memory address.
Similarly, when a program section is relocatable, the value of the
current location counter is relocatable. A relocation bias calculated
at link time is added to the apparent value of the current location counter
to establish its effective absolute address at execution time.
(The user can also force the linker to relocate sections defined
as absolute. This may be required under special circumstances.)

If present, a label must be the first field in a source statement and
must be terminated by a colon (:).  For example, if the value of the
current location counter is absolute 01F0(H), the statement:
.skip;.indent 6
abcd:	nop
.skip;.break
assigns the value 01F0(H) to the label abcd.  If the location counter
value were relocatable, the final value of abcd would be 01F0(H)+K,
where K represents the relocation bias of the program section, as
calculated by the linker at link time.

More than one label may appear within a single label field.
Each label so specified is assigned the same address value.  For
example, if the value of the current location counter is 1FF0(H),
the multiple labels in the following statement are each assigned
the value 1FF0(H):

.skip;.indent 6
abcd:	a_q:	$abc:	nop

Multiple labels may also appear on successive lines.  For
example, the statements

.skip
.indent 6;abcd:
.indent 6;a_q:
.indent 6;$abc:	nop
.skip
likewise cause the same value to be assigned to all three labels.

A double colon (::) defines the label as a global symbol.  For
example,  the statement
.skip;.indent 6
abcd::	nop
.skip
establishes the label abcd as a global symbol.  The distinguishing
attribute of a global symbol is that it can be referenced from within an
object module other than the module in which the symbol is defined.
References to this label in other modules are resolved when the
modules are linked as a composite executable image.

.skip;.break
The legal characters for defining labels are:

.skip;
.break;.indent 8;A through Z
.break;.indent 8;a through z
.break;.indent 8;0 through 9
.break;.indent 8;_. (Period)
.break;.indent 8;_$ (Dollar sign)
.break;.indent 8;__ (underscore)


A label may be any length, however only the first 79 characters
are significant and, therefore must be unique among all labels in the
source program (not necessarily among separately compiled modules).
An error code(s)
(m#or#p) will be generated in the assembly listing if the first 79
characters in two or more labels are the same.  The m code is caused
by the redeclaration of the symbol or its reference by another statement.
The p code is generated because the symbols location is changing on each
pass through the source file.

The label must not start with the characters 0-9, as this designates a
reusable symbol with special attributes described in a later section.

The label must not start with the sequence $$, as this represents the
temporary radix 16 for constants.


.header level 3;Operator Field

The operator field specifies the action to be performed.  It may
consist of an instruction mnemonic (op code) or an assembler directive.

When the operator is an instruction mnemonic, a machine instruction is
generated and the assembler evaluates the addresses of the operands
which follow.  When the operator is a directive ASxxxx performs certain
control actions or processing operations during assembly of the source
program.

Leading and trailing spaces or tabs in the operator field have no
significance;  such characters serve only to separate the operator
field from the preceeding and following fields.

An operator is terminated by a space, tab or end of line.


.header level 3;Operand Field

When the operator is an instruction mnemonic (op code), the operand
field contains program variables that are to be evaluated/manipulated
by the operator.

Operands may be expressions or symbols, depending on the operator.
Multiple expressions used in the operand fields may be separated
by a comma.  An operand should be preceeded by an operator field;
if it is not, the statement will give an error (q or o). All operands
following instruction mnemonics are treated as expressions.

The operand field is terminated by a semicolon when the field is followed
by a comment.  For example, in the following statement:
.skip;.indent 6
label:	lda	abcd,x		;Comment field
.skip
the tab between lda and abcd terminates the operator field and
defines the beginning of the operand field;  a comma separates the
operands abcd and x; and a semicolon terminates the operand field
and defines the beginning of the comment field.  When no comment field
follows, the operand field is terminated by the end of the source line.


.header level 3;Comment Field

The comment field begins with a semicolon and extends through the
end of the line.  This field is optional and may contain any 7-bit
ascii character except null.

Comments do not affect assembly processing or program execution.


.header level 1;SYMBOLS AND EXPRESSIONS

This section describes the generic components of the ASxxxx assemblers:
the character set,  the conventions observed in constructing symbols,
and the use of numbers, operators, and expressions.


.header level 2;Character Set

The following characters are legal in ASxxxx source programs:

.list 1
.list element
The letters A through Z.  Both upper- and lower-case letters
are acceptable.  The assemblers, by default, are case sensitive, i.e.
ABCD and abcd are not the same symbols. (The assemblers can be made
case insensitive by using the -z command line option.)
.list element
The digits 0 through 9
.list element
The characters  _. (period),  _$ (dollar sign), and  __ (underscore).
.list element
The special characters listed in Tables 1 through 6.
.end list

Tables 1 through 6 describe the various ASxxxx label and field
terminators, assignment operators, operand separators, assembly,
unary, binary, and radix operators.

.page
.test page 15
Table#1#########Label Terminators and Assignment Operators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
:###Colon###############
Label terminator.
.skip;.indent -24
::##Double#colon########
Label Terminator; defines the label as a global label.
.skip;.indent -24
_=###Equal#sign##########
Direct assignment operator.
.skip;.indent -24
_=_=##Global#equal########
Direct assignment operator; defines the symbol as a global symbol.
.skip;.indent -24
_=_:##Local#equal#########
Direct assignment operator; defines the symbol as a local symbol.
.left margin -32
.skip
----------------------------------------------------------------
.skip 5

.test page 12
Table#2#########Field Terminators and Operand Separators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
####Tab#################
Item or field terminator.
.skip;.indent -24
####Space###############
Item or field terminator.
.skip;.indent -24
,###Comma###############
Operand field separator.
.skip;.indent -24
;###Semicolon###########
Comment field indicator.
.left margin -32
.skip
----------------------------------------------------------------
.skip 5

.test page 15
Table#3#########Assembler Operators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
_####Number#sign#########
Immediate expression indicator.
.skip;.indent -24
_.###Period##############
Current location counter.
.skip;.indent -24
(###Left#parenthesis####
Expression delimiter.
.skip;.indent -24
)###Right#parenthesis###
Expression delimeter.
.left margin -32
.skip
----------------------------------------------------------------
.skip 5

.test page 26
Table#4#########Unary Operators
.break
----------------------------------------------------------------
.left margin +40
.skip;.indent -32
_<###Left#bracket########_<FEDC###
Produces the lower byte value of the expression. (DC)
.skip;.indent -32
_>###Right#bracket#######_>FEDC###
Produces the upper byte value of the expression. (FE)
.skip;.indent -32
_+###Plus#sign###########_+A######
Positive value of A
.skip;.indent -32
_-###Minus#sign##########_-A######
Produces the negative (2's complement) of A.
.skip;.indent -32
_~###Tilde###############_~A######
Produces the 1's complement of A.
.skip;.indent -32
_'###Single#quote########_'D######
Produces the value of the character D.
.skip;.indent -32
_"###Double#quote########_"AB#####
Produces the double byte value for AB.
.skip;.indent -32
_\###Backslash###########_'_\n#####
Unix style characters
.break
_\b, _\f, _\n, _\r, _\t
.indent -32
#####################or#_'_\001###
or octal byte values.
.left margin -40
.skip
----------------------------------------------------------------
.skip 5

.test page 40
Table#5#########Binary Operators
.break
----------------------------------------------------------------
.left margin +40
.skip;.indent -32
_<_<##Double##########0800#_<_<#4###
Produces the 4 bit
.indent -32
####Left#bracket################
left-shifted value of 0800. (8000)
.skip;.indent -32
_>_>##Double##########0800#_>_>#4###
Produces the 4 bit
.indent -32
####Right#bracket###############
right-shifted value of 0800. (0080)
.skip;.indent -32
_+###Plus#sign#######A#_+#B#######
Arithmetic Addition operator.
.skip;.indent -32
_-###Minus#sign######A#_-#B#######
Arithmetic Subtraction operator.
.skip;.indent -32
*###Asterisk########A#*#B#######
Arithmetic Multiplication operator.
.skip;.indent -32
/###Slash###########A#/#B#######
Arithmetic Division operator.
.skip;.indent -32
_&###Ampersand#######A#_&#B#######
Logical AND operator.
.skip;.indent -32
_|###Bar#############A#_|#B#######
Logical OR operator.
.skip;.indent -32
_%###Percent#sign####A#_%#B#######
Modulus operator.
.skip;.indent -32
_^###Up#arrow#or#####A#_^#B#######
EXCLUSIVE OR operator.
.indent -32
####circumflex
.left margin -40
.skip
----------------------------------------------------------------
.skip 5

.test page 12
Table#6#########Temporary Radix Operators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
$%,###0b,#0B############
Binary radix operator.
.skip;.indent -24
$_&,###0o,#0O,#0q,#0Q####
Octal radix operator.
.skip;.indent -24
$_#,###0d,#0D############
Decimal radix operator.
.skip;.indent -24
$$,###0h,#0H,#0x,#0X####
Hexidecimal radix operator.
.left margin -24
.skip 2
Potential ambiguities arising from the use of 0b and 0d as
temporary radix operators may be circumvented by preceding
all non-prefixed hexidecimal numbers with 00.  Leading 0's are
required in any case where the first hexidecimal digit is abcdef
as the assembler will treat the letter sequence as a label.
.left margin -8
.skip
----------------------------------------------------------------
.skip 5


.header level 2;User-Defined Symbols

User-defined symbols are those symbols that are equated to a specific value
through a direct assignment statement or appear as labels.  These symbols
are added to the User Symbol Table as they are encountered during
assembly.
.skip
The following rules govern the creation of user-defined symbols:
.list 1
.list element
Symbols can be composed of alphanumeric characters,
dollar signs (_$), periods (_.), and underscores (__) only.
.list element
The first character of a symbol must not be a number
(except in the case of reusable symbols).
.list element
The first 79 characters of a symbol must be unique.
A symbol can be written with more than 79 legal characters,
but the 80th and subsequent characters are ignored.
.list element
Spaces and Tabs must not be embedded within a symbol.
.end list


.header level 2;Reusable Symbols

Reusable symbols are specially formatted symbols used as labels within a
block of coding that has been delimited as a reusable symbol block.
Reusable symbols are of the form n$, where n is a decimal integer from
0 to 65535, inclusive.  Examples of reusable symbols are:
.skip
.indent 6;1$
.indent 6;27$
.indent 6;138$
.indent 6;244$

The range of a reusable symbol block consists of those statements
between two normally constructed symbolic labels. Note that a
statement of the form:
.skip
.indent 6;ALPHA = EXPRESSION
.skip
is a direct assignment statement but does not create a label and thus
does not delimit the range of a reusable symbol block.

Note that the range of a reusable symbol block may extend across
program areas.

Reusable symbols provide a convenient means of generating labels for branch
instructions and other such references within reusable symbol blocks.
Using reusable symbols reduces the possibility of symbols with multiple
definitions appearing within a user program. In addition, the use of reusable
symbols differentiates entry-point labels from other labels, since
reusable labels cannot be referenced from outside their respective
symbol blocks.  Thus, reusable symbols of the same name can appear
in other symbol blocks without conflict. Reusable symbols require
less symbol table space than normal symbols. Their use is recommended.

The use of the same reusable symbol within a symbol block will
generate one or both of the m or p errors.
.test page 15
.skip
Example of reusable symbols:
.skip;.literal
	a:	ldx	#atable	;get table address
		lda	#0d48	;table length
	1$:	clr	,x+	;clear
		deca
		bne	1$
		
	b:	ldx	#btable	;get table address
		lda	#0d48	;table length
	1$:	clr	,x+	;clear
		deca
		bne	1$
.end literal		


.header level 2;Current Location Counter

The period (_.) is the symbol for the current location counter.
When used in the operand field of an instruction, the period
represents the address of the first byte of the instruction:

.skip;.literal
	AS:	ldx	#.	;The period (.) refers to
				;the address of the ldx
				;instruction.
.end literal

When used in the operand field
of an ASxxxx directive, it represents the address of the current
byte or word:

.skip;.literal
	QK = 0

	.word	0xFFFE,.+4,QK	;The operand .+4 in the .word
				;directive represents a value
				;stored in the second of the
				;three words during assembly.
.end literal

If we assume the current value of the program counter is 0H0200, then
during assembly, ASxxxx reserves three words of storage starting at
location 0H0200.  The first value, a hexidecimal constant FFFE, will
be stored at location 0H0200. The second value represented by .+4
will be stored at location 0H0202, its value will be 0H0206 ( = 0H0202 + 4).
The third value defined by the symbol QK will be placed at location
0H0204.

At the beginning of each assembly pass, ASxxxx resets the location
counter.  Normally, consecutive memory locations are assigned
to each byte of object code generated.  However, the value of the
location counter can be changed through a direct assignment statement
of the following form:

.skip
.indent 6;_. = _. _+ expression
.skip

The new location counter can only be specified relative to the current
location counter.  Neglecting to specify the current program counter
along with the expression on the right side of the assignment operator
will generate the (.) error.  (Absolute program areas may use
the .org directive to specify the absolute location of the current
program counter.)
.skip
The following coding illustrates the use of the current location counter:

.skip;.literal
	.area	CODE1	(ABS)	;program area CODE1
				;is ABSOLUTE

	.org	0H100		;set location to
				;0H100 absolute

num1:	ldx	#.+0H10		;The label num1 has
				;the value 0H100.
				;X is loaded with
				;0H100 + 0H10

	.org	0H130		;location counter
				;set to 0H130

num2:	ldy	#.		;The label num2 has
				;the value 0H130.
				;Y is loaded with
				;value 0H130.


	.area	CODE2	(REL)	;program area CODE2
				;is RELOCATABLE

	. = . + 0H20		;Set location counter
				;to relocatable 0H20 of
				;the program section.

num3:	.word	0		;The label num3 has
				;the value
				;of relocatable 0H20.

	. = . + 0H40		;will reserve 0H40
				;bytes of storage as will
	.blkb	0H40		;or
	.blkw	0H20
.end literal

The .blkb and .blkw directives are the preferred methods of allocating
space.


.header level 2;Numbers

ASxxxx assumes that all numbers in the source program are to be interpreted in
decimal radix unless otherwise specified.  The .radix directive may be used
to specify the default as octal, decimal, or hexidecimal.  Individual numbers
can be designated as binary, octal, decimal, or hexidecimal through the
temporary radix prefixes shown in table 6.

Negative numbers must be preceeded by a minus sign;  ASxxxx translates
such numbers into two's complement form.  Positive numbers may (but need
not) be preceeded by a plus sign.

Numbers are always considered to be absolute values,  therefor they are
never relocatable.


.header level 2;Terms

A term is a component of an expression and may be one of the following:
.skip
.list 1
.list element
A number.
.list element
A symbol:
.list 0
.list element
A period (.) specified in an expression causes
the current location counter to be used.
.list element
A User-defined symbol.
.list element
An undefined symbol is assigned a value of zero
and inserted in the User-Defined symbol table as an
undefined symbol.
.end list 0
.list element
A single quote followed by a single ascii character, or
a double quote followed by two ascii characters.
.list element
An expression enclosed in parenthesis.  Any expression
so enclosed is evaluated and reduced to a single term
before the remainder of the expression in which it
appears is evaluated.  Parenthesis, for example, may be
used to alter the left-to-right evaluation of expressions,
(as in A*B_+C versus A*(B_+C)), or to apply a unary operator
to an entire expression (as in -(A_+B)).
.list element
A unary operator followed by a symbol or number.
.end list


.header level 2;Expressions

Expressions are combinations of terms joined together by binary
operators.  Expressions reduce to a value. The evaluation
of an expression includes the determination of its attributes.
A resultant expression value may be one of three types (as described
later in this section): relocatable, absolute, and external.
.skip
.test page 22
Expressions are evaluate with an operand hierarchy as follows:
.skip;.literal
	*	/	%	multiplication,
				division, and
				modulus first.

	+	-		addition and
				subtraction second.

	<<	>>		left shift and
				right shift third.

	^			exclusive or fourth.

	&			logical and fifth.

	|			logical or last

	except that unary operators take precedence over binary
	operators.
.end literal
.skip

A missing or illegal operator terminates the expression analysis,
causing error codes (o) and/or (q) to be generated depending
upon the context of the expression itself.

At assembly time the value of an external (global) expression is equal to
the value of the absolute part of that expression.  For example,
the expression external+4, where 'external' is an external symbol, has
the value of 4.  This expression, however, when evaluated at link time
takes on the resolved value of the symbol 'external', plus 4.

Expressions, when evaluated by ASxxxx, are one of three types:
relocatable, absolute, or external.  The following distinctions
are important:

.list 1
.list element
An expression is relocatable if its value is fixed
relative to the base address of the program area
in which it appears; it will have an offset value
added at link time.  Terms that contain labels
defined in relocatable program areas will have
a relocatable value; similarly, a period (.) in a relocatable
program area, representing the value of the current
program location counter, will also have a relocatable value.
.list element
An expression is absolute if its value is fixed.  An
expression whose terms are numbers and ascii characters
will reduce to an absolute value.  A relocatable expression
or term minus a relocatable term, where both elements being
evaluated belong to the same program area, is an absolute
expression.  This is because every term in a program area
has the same relocation bias.  When one term is subtracted
from the other the relocation bias is zero.
.list element
An expression is external (or global) if it contains
a single global reference (plus or minus an absolute
expression value) that is not defined within the current
program.  Thus, an external expression is only partially
defined following assembly and must be resolved at link time.
.end list


.header level 1;GENERAL ASSEMBLER DIRECTIVES

An ASxxxx directive is placed in the operator field of the source
line. Only one directive is allowed per source line. Each directive
may have a blank operand field or one or more operands.  Legal
operands differ with each directive.


.header level 2;_.module Directive
Format:
.skip;.indent 8
_.module	name

The .module directive causes the name to be included in the assemblers
output file as an identifier for this particular object module.  The
name may be from 1 to 79 characters in length.  The name may not have
any embedded white space (spaces or tabs).  Only one identifier is
allowed per assembled module. The main use of this directive is to
allow the linker to report a modules' use of undefined symbols. At link
time all undefined symbols are reported and the modules referencing them
are listed.


.header level 2;_.title Directive
Format:
.skip;.indent 8
_.title	string

The .title directive provides a character string to be placed on the second
line of each page during listing.  The string begins with the first non
white space character (after any space or tab) and ends with the end
of the line.


.header level 2;_.sbttl Directive
Format:
.skip;.indent 8
_.sbttl	string

The .sbttl directive provides a character string to be placed on the third
line of each page during listing.  The string begins with the first non
white space character (after any space or tab) and ends with the end
of the line.



.header level 2;_.page Directive
Format:
.skip;.indent 8
_.page

The .page directive causes a page ejection with a new heading to be
printed.  The new page occurs after the next line of the source program
is processed, this allows an immediately following .sbttl directive to
appear on the new page. The .page source line will not appear in the
file listing. Paging may be disabled by invoking the -p directive.


.header level 2;_.msg Directive
Format:
.skip;.indent 8
_.msg /string/
.skip;.left margin +16
.indent -16
where:##string##represents a text string.  The string is
printed to the console during the final assembly pass.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .msg
directive will give the (q) error.
.left margin -16

.skip

The _.msg directive is useful to report assembly status or
other information during the assembly process.


.header level 2;_.error Directive
Format:
.skip;.indent 8
_.error exp
.skip;.left margin +16
.indent -16
where:##exp#####represents an absolute expression.  If the evaluation
of the expression results in a non zero value then an 'e' error
is reported and the text line is listed in the generated error.
.left margin -16
.skip

The _.error directive is useful to report configuration or
value errors during the assembly process.
(The _.error directive is identical in
function to the _.assume directive, just perhaps more
descriptive.)


.header level 2;_.byte, _.db, and _.fcb Directives
Format:
.skip;.literal
	.byte	exp		;Stores the binary value
	.db	exp		;of the expression in the
	.fcb	exp		;next byte.

	.byte	exp1,exp2,expn	;Stores the binary values
	.db	exp1,exp2,expn	;of the list of expressions
	.fcb	exp1,exp2,expn	;in successive bytes.

where:	exp,	represent expressions that will be
	exp1,	truncated to 8-bits of data.
	.	Each expression will be calculated,
	.	the high-order byte will be truncated.
	.	Multiple expressions must be
	expn	separated by commas.
.end literal

The .byte, .db, or .fcb directives are used to generate successive
bytes of binary data in the object module.


.header level 2;_.word, _.dw, and _.fdb Directives
Format:
.skip;.literal
	.word	exp		;Stores the binary value
	.dw	exp		;of the expression in
	.fdb	exp		;the next word.

	.word	exp1,exp2,expn	;Stores the binary values
	.dw	exp1,exp2,expn	;of the list of expressions
	.fdb	exp1,exp2,expn	;in successive words.

where:	exp,	represent expressions that will occupy two
	exp1,	bytes of data. Each expression will be
	.	calculated as a 16-bit word expression.
	.	Multiple expressions must be
	expn	separated by commas.
.end literal

The .word, .dw, or .fdb directives are used to generate successive
words of binary data in the object module.


.header level 2;_.3byte and _.triple Directives
Format:
.skip;.literal
	.3byte	exp		;Stores the binary value
	.triple	exp		;of the expression in
				;the next triple (3 bytes).

	.3byte	exp1,exp2,expn	;Stores the binary values
	.triple	exp1,exp2,expn	;of the list of expressions
				;in successive triples
				;(3 bytes).

where:	exp,	represent expressions that will occupy three
	exp1,	bytes of data. Each expression will be
	.	calculated as a 24-bit word expression.
	.	Multiple expressions must be
	expn	separated by commas.
.end literal

The .3byte or .triple directive is used to generate successive
triples of binary data in the object module.  (These directives
are only available in assemblers supporting 24-bit addressing.)


.header level 2;_.4byte and _.quad Directive
Format:
.skip;.literal
	.4byte	exp		;Stores the binary value
	.quad	exp		;of the expression in
				;the next quad (4 bytes).

	.4byte	exp1,exp2,expn	;Stores the binary values
	.quad	exp1,exp2,expn	;of the list of expressions
				;in successive quads
				;(4 bytes).

where:	exp,	represent expressions that will occupy three
	exp1,	bytes of data. Each expression will be
	.	calculated as a 32-bit word expression.
	.	Multiple expressions must be
	expn	separated by commas.
.end literal

The .4byte or .quad directive is used to generate successive quads of
binary data in the object module.  (These directives are only
available in assemblers supporting 32-bit addressing.)


.header level 2;_.blkb, _.ds, _,rmb, and _.rs Directives
Format:
.skip;.literal
	.blkb	N	;reserve N bytes of space
	.ds	N	;reserve N bytes of space
	.rmb	N	;reserve N bytes of space
	.rs	N	;reserve N bytes of space
.end literal

The .blkb, .ds, .rmb, and .rs directives reserve byte blocks in the
object module;


.header level 2;_.blkw, _.blk3, and _.blk4 Directives
Format:
.skip;.literal
	.blkw	N	;reserve N words of space
	.blk3	N	;reserve N triples of space
	.blk4	N	;reserve N quads of space
.end literal

The .blkw directive reserves word blocks; the .blk3 reserves
3 byte blocks(available in assemblers supporting 24-bit addressing);
the .blk4 reserves 4 byte blocks (available in assemblers supporting
32-bit addressing).


.header level 2;_.ascii, _.str, and _.fcc Directives
Format:
.skip;.indent 8
_.ascii	/string/
.skip;.indent 8
_.fcc	/string/
.skip;.indent 8
_.str	/string/
.skip;.left margin +16
.indent -16
where:##string##is a string of printable ascii characters.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .ascii
directive will give the (q) error.
.left margin -16
.skip
The .ascii, .fcc, and .str directives place one binary byte of data
for each character in the string into the object module.


.header level 2;_.ascis and _.strs Directives
Format:
.skip;.indent 8
_.ascis	/string/
.skip;.indent 8
_.strs	/string/
.skip;.left margin +16
.indent -16
where:##string##is a string of printable ascii characters.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .ascis
and .strs directives will give the (q) error.
.left margin -16
.skip;
The .ascis and .strs directives place one binary byte of data for 
each character in the string into the object module. The last
character in the string will have the high order bit set.


.header level 2;_.asciz and _.strz Directives
Format:
.skip;.indent 8
_.asciz	/string/
.skip;.indent 8
_.strz	/string/
.skip;.left margin +16
.indent -16
where:##string##is a string of printable ascii characters.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .asciz
and .strz directive will give the (q) error.
.left margin -16
.skip;
The .asciz and .strz  directives place one binary byte of data for
each character in the string into the object module. Following all
the character data a zero byte is inserted to terminate the
character string.


.header level 2;_.assume Directive
Format:
.skip;.indent 8
_.assume exp
.skip;.left margin +16
.indent -16
where:##exp#####represents an absolute expression.  If the evaluation
of the expression results in a non zero value then an 'e' error
is reported and the text line is listed in the generated error.
.left margin -16
.skip

The _.assume directive is useful to check assumptions about
assembler values.  (The _.assume directive is identical in
function to the _.error directive, just perhaps more
descriptive.)


.header level 2;_.radix Directive
Format:
.skip;.indent 8
_.radix	character
.skip;.left margin +8
.indent -8
where:##character represents a single character specifying the
default radix to be used for succeeding numbers.
The character may be any one of the following:
.left margin -8
.skip;.literal
		B,b	Binary

		O,o	Octal
		Q,q

		D,d	Decimal
		'blank'

		H,h	Hexidecimal
		X,x
.end literal


.header level 2;_.even Directive
Format:
.skip;.indent 8
_.even

The .even directive ensures that the current location counter contains
an even boundary value by adding 1 if the current location is odd.


.header level 2;_.odd Directive
Format:
.skip;.indent 8
_.odd

The .odd directive ensures that the current location counter contains
an odd boundary value by adding one if the current location is even.


.header level 2;_.area Directive
Format:
.skip;.indent 8
_.area	name	[(options)]
.skip;.left margin +16
.indent -16
where:##name####represents the symbolic name of the program section.
This name may be the same as any user-defined symbol
or bank as the area names are independent of all symbols,
labels, and banks.
.skip;.indent -16
########options#specify the type of program or data area:
.break;ABS	absolute (automatically invokes OVR)
.break;REL	relocatable
.break;OVR	overlay
.break;CON	concatenate
.break;NOPAG	non-paged area
.break;PAG	paged area
.skip;.indent -16
########options#specify a code or data segment:
.break;CSEG	Code segment
.break;DSEG	Data segment
.skip;.indent -16
########option##specifies the data area bank:
.break;BANK	Named collection of areas
.left margin -16
.skip

The .area directive provides a means of defining and separating multiple
programming and data sections. The name is the area label used by the
assembler and the linker to collect code from various separately assembled
modules into one section. The name may be from 1 to 79 characters in length.

The options are specified within parenthesis and separated by commas
as shown in the following example:
.skip;.literal
	.area  TEST  (REL,CON)	;This section is relocatable
				;and concatenated with other
				;sections of this program area.

	.area  DATA  (REL,OVR)	;This section is relocatable
				;and overlays other sections
				;of this program area.

	.area  SYS   (ABS,OVR)	;(CON not allowed with ABS)
				;This section is defined as
				;absolute. Absolute sections
				;are always overlayed with
				;other sections of this program
				;area.

	.area  PAGE  (PAG)	;This is a paged section. The
				;section must be on a 256 byte
				;boundary and its length is
				;checked by the linker to be
				;no larger than 256 bytes.
				;This is useful for direct page
				;areas.
.end literal

The default area type is REL_|CON; i.e. a
relocatable section which is concatenated with other sections of code
with the same area name. The ABS option indicates an absolute area.
The OVR and CON options indicate if program sections of the same name
will overlay each other (start at the same location) or be concatenated
with each other (appended to each other).

The area can be specified as either a code segment, CSEG, or a
data segment, DSEG.  The CSEG and DSEG descriptors are
useful when the microprocessor code and data unit allocations
are unequal: e.g. the executable code uses an allocation
of 2 bytes for each instruction and is addressed at an increment
of 1 for every instruction, and the data uses an allocation of
1 byte for each element and is addressed at an increment of 1
for each data byte.  The allocation units are defined by the
architecture of the particular microprocessor.

The .area directive also provides a means of specifying the bank
this area is associated with.  All areas associated with a particular
bank are combined at link time into a block of code/data.

The CSEG, DSEG, and BANK options are specified within the parenthesis
as shown in the following examples:
.skip;.literal
	.area	C_SEG	(CSEG,BANK=C1)
				;This is a code section
				;and is included in bank C1
	.area	D_SEG	(DSEG,BANK=D1)
				;This is a data section
				;and is included in bank D1.
.end literal

Multiple invocations of the .area directive with the same name must
specify the same options or leave the options field blank, this defaults
to the previously specified options for this program area.

.skip
.tp 10
The ASxxxx assemblers automatically provide two program sections:
.skip;.left margin +24
.skip;.indent -16
'__CODE'#########This is the default code/data area.
This program area is of type (REL,CON,CSEG).
.skip;.indent -16
'__DATA'#########This is the default optional data area.
This program area is of type (REL,CON,DSEG).
.left margin -24

.skip
.tp 10
The ASxxxx assemblers also automatically generate two symbols for each
program area:
.skip;.left margin +24
.indent -16
's___<area_>'######This is the starting address of the program area.
.skip;
.indent -16
'l___<area_>'######This is the length of the program area.
.left margin -24

.skip
The .area names and options are never case sensitive.


.header level 2;_.bank Directive
Format:
.skip;.indent 8
_.bank	name	[(options)]
.skip;.left margin +16
.indent -16
where:##name####represents the symbolic name of the bank section.
This name may be the same as any user-defined symbol or
area as the bank names are independent of all symbols,
labels, and areas.  The name may be from 1 to 79 characters in length.
.skip;.indent -16
########options#specify the parameters of the bank:
.break;BASE	base address of bank
.break;SIZE	maximum size of bank
.break;FSFX	file suffix for this bank
.break;MAP	NOICE mapping
.left margin -16
.skip

The .bank directive allows an arbitrary grouping of program
and/or data areas to be communicated to the linker.  The bank
parameters are all optional and are described as follows:

.list 1
.list element
BASE,#the starting address of the bank (default is 0) may
be defined.  This address can be overridden by using the linker
-b option for the first area within the bank.  The bank
address is always specified in 'byte' addressing.  A first
area which is not 'byte' addressed (e.g. a processor
addressed by a 'word' of 2 or more bytes) has the area address
scaled to begin at the 'byte' address.
.list element
SIZE,#the maximum length of the bank specified in bytes.
The size is always specified in terms of bytes.
.list element
FSFX,#the file suffix to be used by the linker for
this bank.  The suffix may not contain embedded white
space.
.list element
MAP,##NOICE mapping parameter for this bank of code/data.
.end list

The options are specified within parenthesis and separated by commas
as shown in the following example:
.skip;.literal
	.BANK  C1  (BASE=0x0100,SIZE=0x1000,FSFX=_C1)
				;This bank starts at 0x0100,
				;has a maximum size of 0x1000,
				;and is to be placed into
				;a file with a suffix of _C1
.end literal

The parameters must be absolute (external symbols are not
allowed.)


.header level 2;_.org Directive
Format:
.skip;.indent 8
_.org	exp
.skip;.left margin +16
.indent -16
where:##exp#####is an absolute expression that becomes the
current location counter.
.left margin -16
.skip
The .org directive is valid only in an absolute program section and
will give a (q) error if used in a relocatable program area.  The .org
directive specifies that the current location counter is
to become the specified absolute value.


.header level 2;_.globl Directive
Format:
.skip;.indent 8
_.globl	sym1,sym2,...,symn
.skip;.literal
where:	sym1,		represent legal symbolic names.
	sym2,...	When multiple symbols are specified,
	symn		they are separated by commas.
.end literal

A .globl directive may also have a label field and/or a comment field.

The .globl directive is provided to export (and thus provide
linkage to) symbols not otherwise defined as global symbols within
a module. In exporting global symbols the directive .globl J is
similar to:
.skip
.indent 6;J _=_= expression or J::

Because object modules are linked by global symbols, these symbols are
vital to a program. All internal symbols appearing within a given program
must be defined at the end of pass 1 or they will be considered undefined.
The assembly directive (-g) can be be invoked to make all undefined
symbols global at the end of pass 1.

Naming a symbol not existing in the current assembly in a .globl
directive will cause a 'u' error.

The .globl directive and == construct can be overridden by a
following .local directive.

.note
The ASxxxx assemblers use the last occurring symbol specification
in the source file(s) as the type shown in the symbol table
and output to the .rel file.
.end note


.header level 2;_.local Directive
Format:
.skip;.indent 8
_.local	sym1,sym2,...,symn
.skip;.literal
where:	sym1,		represent legal symbolic names.
	sym2,...	When multiple symbols are specified,
	symn		they are separated by commas.
.end literal

A .local directive may also have a label field and/or a comment field.

The .local directive is provided to define symbols that are local
to the current assembly process.  Local symbols are not effected
by the assembler option -a (make all symbols global).  In
defining local symbols the directive .local J is similar to:
.skip
.indent 6;J _=_: expression

The .local directive and the =: construct are useful in defining
symbols and constants within a header or definition file that
contains many symbols specific to the current assembly process
that should not be exported into the .rel output file.  A typical
usage is in the definition of SFRs (Special Function Registers)
for a microprocessor.

The .local directive and =: construct can be overridden by a
following .globl directive.

A defined symbol that has not been given a value is considered
an external variable and will cause an 'r' error in a .local
directive and its symbol type will not be changed. An undefined
symbol in a .local directive causes a 'u' error.

.note
The ASxxxx assemblers use the last occurring symbol specification
in the source file(s) as the type shown in the symbol table
and output to the .rel file.
.end note


.header	level 2;_.equ, _.gblequ, and _.lclequ Directives
Format:
.skip;.literal
	sym1	.equ	expr	; equivalent to sym1  = expr
	sym2	.gblequ	expr	; equivalent to sym2 == expr
	sym3	.lclequ	expr	; equivalent to sym3 =: expr

	or

	.equ	sym1,	expr	; equivalent to sym1  = expr
	.gblequ	sym2,	expr	; equivalent to sym2 == expr
	.lclequ	sym3,	expr	; equivalent to sym3 =: expr
.end literal

These alternate forms of equivalence are provided for user
convenience.


.header level 2;_.if, _.else, and _.endif Directives
Format:
.skip;.literal
	.if	expr
	.			;}
	.			;} range of true condition
	.			;}
	.else
	.			;}
	.			;} range of false condition
	.			;}
	.endif
.end literal

The conditional assembly directives allow you to include or exclude
blocks of source code during the assembly process, based on the
evaluation of the test condition.

The range of true condition will be processed if the expression 'expr'
is not zero (i.e. true) and the range of false condition will be
processed if the expression 'expr' is zero (i.e false). The range of
true condition is optional as is the .else directive and the range
of false condition.  The following are all valid .if/.else/.endif
constructions:
.skip;.literal
	.if	A-4		;evaluate A-4
	.byte	1,2		;insert bytes if A-4 is
	.endif			;not zero

	.if	K+3		;evaluate K+3
	.else
	.byte	3,4		;insert bytes if K+3
	.endif			;is zero

	.if	J&3		;evaluate J masked by 3
	.byte	12		;insert this byte if J&3
	.else			;is not zero
	.byte	13		;insert this byte if J&3
	.endif			;is zero
.end literal
.skip 2
The .if/.else/.endif directives may be nested upto 10 levels.

The .page directive is processed within a false condition range
to allow extended textual information to be incorporated in the
source program with out the need to use the comment delimiter (;):
.skip;.literal
	.if	0

	.page
	This text will be bypassed during assembly
	but appear in the listing file.
	.
	.
	.

	.endif
.end literal


.header level 2;_.ifxx, _.else, and _.endif Directives

Additional conditional directives are available to
test the value of an evaluated expression:

.skip;.literal
	.ifne	expr		; true if expr != 0
	.ifeq	expr		; true if expr == 0
	.ifgt	expr		; true if expr >  0
	.iflt	expr		; true if expr <  0
	.ifge	expr		; true if expr >= 0
	.ifle	expr		; true if expr <= 0
.end literal

Format:
.skip;.literal
	.ifxx	expr
	.			;}
	.			;} range of true condition
	.			;}
	.else
	.			;}
	.			;} range of false condition
	.			;}
	.endif
.end literal

The conditional assembly directives allow you to include or exclude
blocks of source code during the assembly process, based on the
evaluation of the test condition.

The range of true condition will be processed if the expression 'expr'
is not zero (i.e. true) and the range of false condition will be
processed if the expression 'expr' is zero (i.e false). The range of
true condition is optional as is the .else directive and the range
of false condition.  The following are all valid .if/.else/.endif
constructions:
.skip;.literal
	.ifne	A-4		;evaluate A-4
	.byte	1,2		;insert bytes if A-4 is
	.endif			;not zero

	.ifeq	K+3		;evaluate K+3
	.byte	3,4		;insert bytes if K+3
	.endif			;is zero

	.ifne	J&3		;evaluate J masked by 3
	.byte	12		;insert this byte if J&3
	.else			;is not zero
	.byte	13		;insert this byte if J&3
	.endif			;is zero
.end literal
.skip 2
The .ifxx/.else/.endif directives may be nested upto 10 levels.


.header level 2;_.ifdef, _.else, and _.endif Directives
Format:
.skip;.literal
	.ifdef	sym
	.			;}
	.			;} range of true condition
	.			;}
	.else
	.			;}
	.			;} range of false condition
	.			;}
	.endif
.end literal

The conditional assembly directives allow you to include or exclude
blocks of source code during the assembly process, based on the
evaluation of the test condition.

The range of true condition will be processed if the symbol 'sym'
has been defined with a .define directive or 'sym' is a variable
with an assigned value else the false range will be processed.
The range of true condition is optional as is the .else directive
and the range of false condition.  The following are all
valid .ifdef/.else/.endif constructions:

.skip;.literal
	.ifdef	sym$1		;lookup symbol sym$1
	.byte	1,2		;insert bytes if sym$1
	.endif			;is defined or
				;assigned a value

	.ifdef	sym$2		;lookup symbol sym$2
	.else
	.byte	3,4		;insert bytes if sym$1
	.endif			;is not defined and
				;not assigned a value

	.ifdef	sym$3		;lookup symbol sym$3
	.byte	12		;insert this byte if sym$3
	.else			;is defined/valued
	.byte	13		;insert this byte if sym$3
	.endif			;is not defined/valued
.end literal
.skip 2
The .ifdef/.else/.endif directives may be nested upto 10 levels.


.header level 2;_.ifndef, _.else, and _.endif Directives
Format:
.skip;.literal
	.ifndef	sym
	.			;}
	.			;} range of true condition
	.			;}
	.else
	.			;}
	.			;} range of false condition
	.			;}
	.endif
.end literal

The conditional assembly directives allow you to include or exclude
blocks of source code during the assembly process, based on the
evaluation of the condition test.

The range of true condition will be processed if the symbol 'sym'
is not defined by a .define directive and a variable 'sym' has
not been assigned a value else the range of false condition will be
processed. The range of true condition is optional as is the .else
directive and the range of false condition.  The following are all
valid .ifndef/.else/.endif constructions:

.skip;.literal
	.ifndef	sym$1		;lookup symbol sym$1
	.byte	1,2		;insert bytes if sym$1 is
	.endif			;not defined and
				;not assigned a value

	.ifndef	sym$2		;lookup symbol sym$2
	.else
	.byte	3,4		;insert bytes if sym$1
	.endif			;is defined or
				;is assigned a value

	.ifndef	sym$3		;lookup symbol sym$3
	.byte	12		;insert this byte if sym$3
	.else			;is not defined/valued
	.byte	13		;insert this byte if sym$3
	.endif			;is defined/valued
.end literal
.skip 2
The .ifndef/.else/.endif directives may be nested upto 10 levels.


.header level 2;_.include Directive
Format:
.skip;.indent 8
_.include	/string/
.skip;.left margin +16
.indent -16
where:##string##represents a string that is the
file specification of an ASxxxx source file.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .include
directive will give the (q) error.
.left margin -16

The .include directive is used to insert a source file within the
source file currently being assembled. When this directive is encountered,
an implicit .page directive is issued. When the end of the specified
source file is reached, an implicit .page directive is issued and
input continues from the previous source file. The maximum nesting
level of source files specified by a .include directive is five.

The total number of separately specified .include files is unlimited
as each .include file is opened and then closed during each pass
made by the assembler.

The default directory path, if none is specified, for any .include file
is the directory path of the current file.  For example: if the
current source file, D:_\proj_\file1.asm, includes a file specified
as "include1" then the file D:_\proj_\include1.asm is opened.


.header level 2;_.define and _.undefine Directives
Format:
.skip;.indent 8
_.define########keyword	/string/
.skip;.indent 8
_.undefine######keyword
.skip;.left margin +16
.indent -16
where:##keyword#is the substitutable string which must
start with a letter and may contain any combination of
digits and letters.
.skip
.indent -16
where:##string##represents a string that is
substituted for the keyword.  The string may contain
any sequence of characters including white space.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .define
directive will give the (q) error.
.left margin -16

The .define directive specifies a user defined string
which is substituted for the keyword.  The substitution
string may itself contain other keywords that are
substitutable.  The assembler resumes the parse of the
line at the point the keyword was found.  Care must be
excersized to avoid any circular references within
_.define directives, otherwise the assembler may enter
a 'recursion runaway' resulting in an 's' error.

The .undefine directive removes the keyword as a
substitutable string.  No error is returned if
the keyword was not defined.


.header level 2;_.\s\e\t\d\p Directive

.break
Format:
.skip;.indent 8
_.setdp [base [,area]]
.skip
The set direct page directive has a common format in all the
assemblers supporting a paged mode.
The .setdp directive is used to inform the assembler of the current
direct page region and the offset address within the selected area.
The normal invocation methods are:
.tp 10;.skip
.literal
	.area	DIRECT	(PAG)
	.setdp

	or

	.setdp	0,DIRECT
.end literal
.skip
for all the 68xx microprocessors (the 6804 has only the paged ram area).
The commands specify that the direct page is in area DIRECT and its offset
address is 0 (the only valid value for all but the 6809 microprocessor).
Be sure to place the DIRECT area at address 0 during linking.
When the base address and area are not specified, then
zero and the current area are the defaults.  If a .setdp directive
is not issued the assembler defaults the direct page to the
area "__CODE" at offset 0.

The assembler verifies that any local variable used in a direct
variable reference is located in this area. Local variable and constant value
direct access addresses are checked to be within the address range
from 0 to 255.

External direct references are assumed by the assembler to be in
the correct area and have valid offsets.
The linker will check all direct page relocations
to verify that they are within the correct area.

The 6809 microprocessor allows the selection of the direct page
to be on any 256 byte boundary by loading the appropriate value
into the dp register. Typically one would like to select the page
boundary at link time, one method follows:
.tp 12;.skip
.literal
	.area	DIRECT	(PAG)	; define the direct page
	.setdp
	.
	.
	.
	.area	PROGRAM
	.
	ldd	#DIRECT		; load the direct page register
	tfr	a,dp		; for access to the direct page
.end literal
.skip
.tp 10
At link time specify the base and global equates to locate the
direct page:
.skip
.literal
	-b DIRECT = 0x1000
	-g DIRECT = 0x1000
.end literal
.skip
Both the area address and offset value must be specified (area and
variable names are independent). The linker will verify that the
relocated direct page accesses are within the direct page.

.tp 20
The preceeding sequence could be repeated for multiple paged areas, however
an alternate method is to define a non-paged area and use the .setdp
directive to specify the offset value:
.skip
.literal
	.area	DIRECT		; define non-paged area
	.
	.
	.
	.area	PROGRAM
	.
	.setdp	0,DIRECT	; direct page area
	ldd	#DIRECT		; load the direct page register
	tfr	a,dp		; for access to the direct page
	.
	.
	.setdp	0x100,DIRECT	; direct page area
	ldd	#DIRECT+0x100	; load the direct page register
	tfr	a,dp		; for access to the direct page
.end literal
.skip
The linker will verify that subsequent direct page references are in
the specified area and offset address range.
It is the programmers responsibility to load the dp register with the
correct page segment corresponding to the .setdp base address specified.

For those cases where a single piece of code must access a defined
data structure within a direct page and there are many pages, define
a dumby direct page linked at address 0. This dumby page is used
only to define the variable labels. Then load the dp register with
the real base address but donot use a .setdp directive.  This method
is equivalent to indexed addressing, where the dp register is the
index register and the direct addressing is the offset.


.header level 2;_.16bit, _.24bit, and _.32bit Directives
Format:
.skip;.literal
	.16bit		;specify 16-bit addressing
	.24bit		;specify 24-bit addressing
	.32bit		;specify 32-bit addressing
.end literal
.skip;

The _.16bit, _.24bit, and _.32bit directives are special
directives for assembler configuration when default values are
not used.


.header level 2;.\m\s\b Directive 
.break
Format:
.skip;.indent 8
_.msb	n
.skip
  The .msb directive is only available in selected assemblers
which support 24 or 32-bit addressing.

  The assembler operator '>' selects the upper byte (MSB) when
included in an assembler instruction.  The default assembler
mode is to select bits <15:8> as the MSB.  The .msb directive
allows the programmer to specify a particular byte as the
'MSB' when the address space is larger than 16-bits.

  The assembler directive ##.msb#n## configures the assembler
to select a particular byte as MSB. Given a 32-bit address
of MNmn (M(3) is <31:24>, N(2) is <23:16>, m(1) is <15:8>,
and n(0) is <7:0>) the following examples show how to select
a particular address byte:
.skip
.literal
	.msb 1		;select byte 1 of address
			;<M(3):N(2):m(1):n(0)>
	LD A,>MNmn	;byte m <15:8> ==>> A
	...

	.msb 2		;select byte 2 of address
			;<M(3):N(2):m(1):n(0)>
	LD A,>MNmn	;byte N <23:16> ==>> A
	...

	.msb 3		;select byte 3 of address
			;<M(3):N(2):m(1):n(0)>
	LD A,>MNmn	;byte M <31:24> ==>> A
	...
.end literal


.header level 2;_.end Directive
Format:
.skip;.indent 8
_.end
.skip;.indent 8
_.end	exp
.skip;.left margin +16
.indent -16
where:##exp#####represents any expression, including
constants, symbols, or labels.
.left margin -16
.skip

The _.end directive is used to specify a code entry point
to be included in the linker output file.  Review the I86
and S record formats described in the linker section
for details.

The _.end directive without an expression is ignored.


.tp 48
.header level 1;INVOKING ASXXXX

Starting an ASxxxx assembler without any arguments provides
the following option list and then exits:

.skip
.literal
Usage: [-options] file1 [file2 file3 ...]
  -d   Decimal listing
  -q   Octal   listing
  -x   Hex     listing (default)
  -g   Undefined symbols made global
  -a   All user symbols made global
  -b   Display .define substitutions in listing
  -bb  and display without .define substitutions
  -c   Enable instruction cycle count in listing
  -j   Enable NoICE Debug Symbols
  -y   Enable SDCC  Debug Symbols
  -l   Create list   output file1[.lst]
  -o   Create object output file1[.rel]
  -s   Create symbol output file1[.sym]
  -p   Disable listing pagination
  -u   Disable .list/.nlist processing
  -w   Wide listing format for symbol table
  -z   Disable case sensitivity for symbols
  -f   Flag relocatable references by  `   in listing file
  -ff  Flag relocatable references by mode in listing file
.end literal
.skip 2

The  ASxxxx  assemblers are command line oriented.  Most
sytems require the option(s) and file(s) arguments to
follow the ASxxxx assembler name:
.skip
as6809  [-Options] file1 [file2 file3 ...]
.skip 2
Some systems may request the arguments after the assembler is
started at a system specific prompt:
.skip
as6809
.br
argv:   [-Options] file1 [file2 file3 ...]
.skip 2
The ASxxxx options in some more detail:
.skip;.literal
	-d	decimal	listing
	-q	octal	listing
	-x	hex	listing (default)

		The listing radix affects the
		.lst, .rel, and .sym files.

	-g	undefined symbols made global

		Unresolved (external) variables
		and symbols are flagged as global.

	-a	all user symbols made global

		All defined (not local or external)
		variables and symbols are flagged
		as global.

	-b	display .define substitutions in listing

		If a .define substitution has been applied
		to an assembler source line the source
		line is printed with the substitution.

	-bb	and display without .define substitutions

		If a .define substitution has been applied
		to an assembler source line the source
		line is first printed without substitution
		followed by the line with the substitution.

	-j	enable NOICE debug symbols
	-y	enable SDCC debug symbols

	-l	create list   output file1.lst

		If -s (symbol table output) is not
		specified the symbol table is included
		at the end of the listing file.

	-o	create object output file1.rel
	-s	create symbol output file1.sym

	-p	disable listing pagination
	-u	disable .list/.nlist processing
	-w	wide listing format for symbol table

	-z	disable case sensitivity for symbols

	-f	by  `   in the listing file
	-ff	by mode in the listing file

		Relocatable modess are flagged by byte
		position (LSB, Byte 2, Byte 3, MSB)
		*nMN	paged,
		uvUV	unsigned,
		rsRS	signed,
		pqPQ	program counter relative.
.end literal

The file name for the .lst, .rel, and .sym files is the first file name
specified in the command line. All output files are ascii text files
which may be edited, copied, etc.  The output files are the concatenation
of all the input files, if files are to be assembled independently
invoke the assembler for each file.

The .rel file contains a radix directive so that the linker will
use the proper conversion for this file. Linked files may have
different radices.


.header level 1;ERRORS

The ASxxxx assemblers provide limited diagnostic error codes
during the assembly process, these errors will be noted in the
listing file and printed on the stderr device.

The assembler reports the errors on the stderr device as
.skip
.lit
	?ASxxxx-Error-<*> in line nnn of filename
.end lit
.skip
where * is the error code, nnn is the line number, and filename
is the source/include file.

The errors are:
.left margin +12
.skip;.indent -6
(_.)###
This error is caused by an absolute direct assignment
of the current location counter
.indent 6
_. = expression (incorrect)
.break
rather than the correct
.indent 6
_. = _. + expression
.skip;.indent -6
(a)###
Indicates a machine specific addressing or
addressing mode error.
.skip;.indent -6
(b)###
Indicates a direct page boundary error.
.skip;.indent -6
(d)###
Indicates a direct page addressing error.
.skip;.indent -6
(e)###
Caused by a .error or .assume directive.
.skip;.indent -6
(i)###
Caused by an .include file error or
an .if/.endif mismatch.
.skip;.indent -6
(m)###
Multiple definitions of the same label,
multiple .module directives, or multiple
conflicting attributes in an .area or .bank
directive.
.skip;.indent -6
(o)###
Directive or mnemonic error or the use
of the .org directive in a relocatable area.
.skip;.indent -6
(p)###Phase error: label location changing between
passes 2 and 3. Normally caused by having
more than one level of forward referencing.
.skip;.indent -6
(q)###
Questionable syntax: missing or improper
operators, terminators, or delimiters.
.skip;.indent -6
(r)###
Relocation error: logic operation attempted on
a relocatable term, addition of two relocatable terms,
subtraction of two relocatable terms not within the
same programming area or external symbols.
.skip;.indent -6
(s)###
String Substitution / recursion error.
.skip;.indent -6
(u)###
Undefined symbol encountered during assembly.
.skip;.indent -6
(z)###
Divide by 0 or Modulus by 0 error: result is 0.
.left margin -12


.header level 1;LISTING FILE

The (-l) option produces an ascii output listing file. Each page of output
contains a five line header:
.skip
.list 1
.list element;The ASxxxx program name and page number
.list element;Assembler Radix and Address Bits
.list element;Title from a .title directive (if any)
.list element;Subtitle from a .sbttl directive (if any)
.list element;Blank line
.end list

.skip 2;.break
Each succeeding line contains five fields:
.skip
.list 1
.list element;Error field (first two characters of line)
.list element;Current location counter
.list element;Generated code in byte format
.list element;Source text line number
.list element;Source text
.end list

The error field may contain upto 2 error flags indicating any errors
encountered while assembling this line of source code.

The current location counter field displays the 16-bit, 24-bit,
or 32-bit program position. This field will be in the selected radix.

The generated code follows the program location. The listing
radix determines the number of bytes that will be displayed in this
field. Hexidecimal listing allows six bytes of data within the field,
decimal and octal allow four bytes within the field. If more than
one field of data is generated from the assembly of a single line of
source code, then the data field is repeated on successive lines.

The source text line number is printed in decimal and is followed by
the source text.  A Source line with a .page directive is never listed.

Two additional options are available for printing the source
line text.  If the -b option is specified then the listed
source line contains all the .define substitutions.  If the -bb
option is specified then the original source line is printed before
the source line with substitutions.

Two data field options are available to flag those bytes which will
be relocated by the linker. If the -f option is specified then
each byte to be relocated will be preceeded by the '`' character.
If the -ff option is specified  then each byte to be relocated
will be preceeded by one of the following characters:

.list 1
.list element;*###paged relocation
.list element;u###low##byte of unsigned word or unsigned byte
.list element;v###high#byte of unsigned word
.list element;p###PCR low##byte of word relocation or PCR byte
.list element;q###PCR high#byte of word relocation
.list element;r###low##byte relocation or byte relocation
.list element;s###high#byte relocation
.end list

Assemblers which use 24-bit or 32-bit addressing use an extended
flagging mode:

.list 1
.list element;*###paged relocation
.list element;u###1st##byte of unsigned value
.list element;v###2nd##byte of unsigned value
.list element;U###3rd##byte of unsigned value
.list element;V###4th##byte of unsigned value
.list element;p###PCR 1st##byte of relocation value or PCR byte
.list element;q###PCR 2nd##byte of relocation value
.list element;P###PCR 3rd##byte of relocation value
.list element;Q###PCR 4th##byte of relocation value
.list element;r###1st##byte of relocation value or byte relocation
.list element;s###2nd##byte of relocation value
.list element;R###3rd##byte of relocation value
.list element;S###4th##byte of relocation value
.end list


.header level 1;SYMBOL TABLE FILE

The symbol table has two parts:

.list 1
.list element
The alphabetically sorted list of symbols and/or labels
defined or referenced in the source program.
.list element
A list of the program areas defined during assembly
of the source program.
.end list

.break;
The sorted list of symbols and/or labels contains the following information:

.list 1
.list element
Program area number (none if absolute value or external)
.list element
The symbol or label
.list element
Directly assigned symbol is denoted with an (=) sign
.list element
The value of a symbol, location of a label relative
to the program area base address (=0), or a **** indicating
the symbol or label is undefined.
.list element
The characters: G - global, R - relocatable, and X - external.
.end list

The list of program areas provides the correspondence between the
program area numbers and the defined program areas, the size of the
program areas, and the area flags (attributes).


.header level 1;OBJECT FILE

The object file is an ascii file containing the information needed
by the linker to bind multiple object modules into a complete
loadable memory image. The object module contains the following
designators:
.skip;.literal
	[XDQ][HL][234]
		X	Hexidecimal radix
		D	Decimal radix
		Q	Octal radix

		H	Most significant byte first
		L	Least significant byte first

		2	16-Bit Addressing
		3	24-Bit Addressing
		4	32-Bit Addressing

	H	Header 
	M	Module
	G	Merge Mode
	B	Bank
	A	Area
	S	Symbol
	T	Object code
	R	Relocation information
	P	Paging information
.end literal

Refer to the linker for a detailed description of each of the
designators and the format of the information contained in the
object file.

